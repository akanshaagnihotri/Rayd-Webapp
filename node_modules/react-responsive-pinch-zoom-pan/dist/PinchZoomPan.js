'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactFontawesome = require('@fortawesome/react-fontawesome');

var _reactFontawesome2 = _interopRequireDefault(_reactFontawesome);

var _faPlus = require('@fortawesome/fontawesome-free-solid/faPlus');

var _faPlus2 = _interopRequireDefault(_faPlus);

var _faMinus = require('@fortawesome/fontawesome-free-solid/faMinus');

var _faMinus2 = _interopRequireDefault(_faMinus);

require('./styles.css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SNAP_TOLERANCE = 0.001;
var OVER_TRANSFORMATION_TOLERANCE = 0.05;
var DOUBLE_TAP_THRESHOLD = 300;
var ANIMATION_SPEED = 0.1;

var snapToTarget = function snapToTarget(value, target, tolerance) {
    var withinRange = Math.abs(target - value) < tolerance;
    return withinRange ? target : value;
};

var rangeBind = function rangeBind(lowerBound, upperBound, value) {
    return Math.min(upperBound, Math.max(lowerBound, value));
};

var invert = function invert(value) {
    return value * -1;
};

var getRelativePosition = function getRelativePosition(_ref, relativeToElement) {
    var clientX = _ref.clientX,
        clientY = _ref.clientY;

    var rect = relativeToElement.getBoundingClientRect();
    return {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
};

var getMidpoint = function getMidpoint(pointA, pointB) {
    return {
        x: (pointA.x + pointB.x) / 2,
        y: (pointA.y + pointB.y) / 2
    };
};

var getDistanceBetweenPoints = function getDistanceBetweenPoints(pointA, pointB) {
    return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));
};

var ZoomOutButton = function ZoomOutButton(_ref2) {
    var disabled = _ref2.disabled,
        onClick = _ref2.onClick;
    return _react2.default.createElement(
        'button',
        { className: 'iconButton', style: { margin: '10px' }, onClick: onClick, disabled: disabled },
        _react2.default.createElement(_reactFontawesome2.default, { icon: _faMinus2.default })
    );
};

var ZoomInButton = function ZoomInButton(_ref3) {
    var disabled = _ref3.disabled,
        onClick = _ref3.onClick;
    return _react2.default.createElement(
        'button',
        { className: 'iconButton', style: { margin: '10px', marginLeft: '0px' }, onClick: onClick, disabled: disabled },
        _react2.default.createElement(_reactFontawesome2.default, { icon: _faPlus2.default })
    );
};

var PinchZoomPan = function (_React$Component) {
    _inherits(PinchZoomPan, _React$Component);

    function PinchZoomPan(props) {
        _classCallCheck(this, PinchZoomPan);

        var _this = _possibleConstructorReturn(this, (PinchZoomPan.__proto__ || Object.getPrototypeOf(PinchZoomPan)).call(this, props));

        _this.state = {};

        _this.handleTouchStart = _this.handleTouchStart.bind(_this);
        _this.handleTouchMove = _this.handleTouchMove.bind(_this);
        _this.handleTouchEnd = _this.handleTouchEnd.bind(_this);
        _this.handleMouseDown = _this.handleMouseDown.bind(_this);
        _this.handleMouseMove = _this.handleMouseMove.bind(_this);
        _this.handleMouseUp = _this.handleMouseUp.bind(_this);
        _this.handleMouseWheel = _this.handleMouseWheel.bind(_this);
        _this.handleWindowResize = _this.handleWindowResize.bind(_this);
        _this.handleImageLoad = _this.handleImageLoad.bind(_this);
        return _this;
    }

    //event handlers


    _createClass(PinchZoomPan, [{
        key: 'handleTouchStart',
        value: function handleTouchStart(event) {
            this.animation && cancelAnimationFrame(this.animation);

            var touches = event.touches;
            if (touches.length === 2) {
                this.pinchStart(touches);
                this.lastPanPointerPosition = null;
            } else if (touches.length === 1) {
                this.pointerDown(touches[0]);
            }
        }
    }, {
        key: 'handleTouchMove',
        value: function handleTouchMove(event) {
            var touches = event.touches;
            if (touches.length === 2) {
                //suppress viewport scaling
                event.preventDefault();
                this.pinchChange(touches);
            } else if (touches.length === 1) {
                var swipingDown = this.pan(touches[0]) > 0;
                if (swipingDown && this.state.top < 0) {
                    //suppress pull-down-refresh since swiping down will reveal the hidden overflow of the image
                    event.preventDefault();
                }
            }
        }
    }, {
        key: 'handleTouchEnd',
        value: function handleTouchEnd(event) {
            if (event.touches && event.touches.length > 0) return null;

            //We allow transient +/-5% over-pinching.
            //Animate the bounce back to constraints if applicable.
            this.ensureValidTransform(ANIMATION_SPEED);

            this.pointerUp(event.timeStamp);

            //suppress mouseUp, in case of tap
            event.preventDefault();
        }
    }, {
        key: 'handleMouseDown',
        value: function handleMouseDown(event) {
            this.animation && cancelAnimationFrame(this.animation);
            this.mouseDown = true;
            this.pointerDown(event);
        }
    }, {
        key: 'handleMouseMove',
        value: function handleMouseMove(event) {
            if (!this.mouseDown) return null;
            this.pan(event);
        }
    }, {
        key: 'handleMouseUp',
        value: function handleMouseUp(event) {
            this.pointerUp(event.timeStamp);
            if (this.mouseDown) {
                this.mouseDown = false;
            }
        }
    }, {
        key: 'handleMouseWheel',
        value: function handleMouseWheel(event) {
            this.animation && cancelAnimationFrame(this.animation);
            var point = getRelativePosition(event, this.container);
            if (event.deltaY > 0) {
                if (this.state.scale > this.minScale) {
                    this.zoomOut(point);
                    event.preventDefault();
                }
            } else if (event.deltaY < 0) {
                if (this.state.scale < this.props.maxScale) {
                    this.zoomIn(point);
                    event.preventDefault();
                }
            }
        }
    }, {
        key: 'handleWindowResize',
        value: function handleWindowResize(event) {
            this.ensureConstraints();
        }
    }, {
        key: 'handleImageLoad',
        value: function handleImageLoad() {
            this.ensureConstraints();
        }

        //actions

    }, {
        key: 'pointerDown',
        value: function pointerDown(clientPosition) {
            this.lastPanPointerPosition = getRelativePosition(clientPosition, this.container);
        }
    }, {
        key: 'pan',
        value: function pan(pointerClientPosition) {
            var pointerPosition = getRelativePosition(pointerClientPosition, this.container);
            var translateX = pointerPosition.x - this.lastPanPointerPosition.x;
            var translateY = pointerPosition.y - this.lastPanPointerPosition.y;
            var top = this.state.top + translateY;
            var left = this.state.left + translateX;

            //use 0 tolerance to prevent over-panning (doesn't look good)
            this.move(top, left, 0);
            this.lastPanPointerPosition = pointerPosition;
            return translateY > 0 ? 1 : //swiping down
            translateY < 0 ? -1 : //swiping up
            0;
        }
    }, {
        key: 'pointerUp',
        value: function pointerUp(timeStamp) {
            if (this.lastPointerUpTimeStamp && this.lastPointerUpTimeStamp + DOUBLE_TAP_THRESHOLD > timeStamp) {
                //reset
                this.transformToProps(ANIMATION_SPEED);
            }

            this.lastPointerUpTimeStamp = timeStamp;
        }
    }, {
        key: 'move',
        value: function move(top, left, tolerance) {
            var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            this.applyTransform(top, left, this.state.scale, tolerance, speed);
        }
    }, {
        key: 'pinchStart',
        value: function pinchStart(touches) {
            var pointA = getRelativePosition(touches[0], this.container);
            var pointB = getRelativePosition(touches[1], this.container);
            this.lastPinchLength = getDistanceBetweenPoints(pointA, pointB);
        }
    }, {
        key: 'pinchChange',
        value: function pinchChange(touches) {
            var pointA = getRelativePosition(touches[0], this.container);
            var pointB = getRelativePosition(touches[1], this.container);
            var length = getDistanceBetweenPoints(pointA, pointB);
            var scale = this.state.scale * length / this.lastPinchLength;
            var midpoint = getMidpoint(pointA, pointB);

            this.zoom(scale, midpoint, OVER_TRANSFORMATION_TOLERANCE);

            this.lastPinchMidpoint = midpoint;
            this.lastPinchLength = length;
        }
    }, {
        key: 'zoomIn',
        value: function zoomIn(midpoint) {
            midpoint = midpoint || {
                x: this.container.offsetWidth / 2,
                y: this.container.offsetHeight / 2
            };
            this.zoom(this.state.scale * 1.05, midpoint, 0);
        }
    }, {
        key: 'zoomOut',
        value: function zoomOut(midpoint) {
            midpoint = midpoint || {
                x: this.container.offsetWidth / 2,
                y: this.container.offsetHeight / 2
            };
            this.zoom(this.state.scale * 0.95, midpoint, 0);
        }
    }, {
        key: 'zoom',
        value: function zoom(scale, midpoint, tolerance) {
            var speed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            scale = this.getValidTransform(0, 0, scale, tolerance).scale;

            var incrementalScalePercentage = (this.state.scale - scale) / this.state.scale;
            var translateY = (midpoint.y - this.state.top) * incrementalScalePercentage;
            var translateX = (midpoint.x - this.state.left) * incrementalScalePercentage;

            var top = this.state.top + translateY;
            var left = this.state.left + translateX;

            this.applyTransform(top, left, scale, tolerance, speed);
        }

        //state validation and transformation methods

    }, {
        key: 'applyTransform',
        value: function applyTransform(requestedTop, requestedLeft, requestedScale, tolerance) {
            var _this2 = this;

            var speed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

            var _getValidTransform = this.getValidTransform(requestedTop, requestedLeft, requestedScale, tolerance),
                top = _getValidTransform.top,
                left = _getValidTransform.left,
                scale = _getValidTransform.scale;

            if (this.state.scale === scale && this.state.top === top && this.state.left === left) {
                return;
            }

            if (speed > 0) {
                var frame = function frame() {
                    var translateY = top - _this2.state.top;
                    var translateX = left - _this2.state.left;
                    var translateScale = scale - _this2.state.scale;

                    var nextTransform = {
                        top: snapToTarget(_this2.state.top + speed * translateY, top, SNAP_TOLERANCE),
                        left: snapToTarget(_this2.state.left + speed * translateX, left, SNAP_TOLERANCE),
                        scale: snapToTarget(_this2.state.scale + speed * translateScale, scale, SNAP_TOLERANCE)
                    };

                    _this2.setState(nextTransform, function () {
                        return _this2.animation = requestAnimationFrame(frame);
                    });
                };
                this.animation = requestAnimationFrame(frame);
            } else {
                this.setState({
                    top: top,
                    left: left,
                    scale: scale
                });
            }
        }
    }, {
        key: 'getValidTransform',
        value: function getValidTransform(top, left, scale, tolerance) {
            var transform = {
                scale: scale || 1,
                top: top || 0,
                left: left || 0
            };
            var lowerBoundFactor = 1.0 - tolerance;
            var upperBoundFactor = 1.0 + tolerance;

            transform.scale = rangeBind(this.minScale * lowerBoundFactor, this.props.maxScale * upperBoundFactor, transform.scale);

            //get dimensions by which scaled image overflows container
            var negativeSpace = this.calculateNegativeSpace(transform.scale);
            var overflow = {
                width: Math.max(0, invert(negativeSpace.width)),
                height: Math.max(0, invert(negativeSpace.height))
            };

            //prevent moving by more than the overflow
            //example: overflow.height = 100, tolerance = 0.05 => top is constrained between -105 and +5
            transform.top = rangeBind(invert(overflow.height) * upperBoundFactor, overflow.height * upperBoundFactor - overflow.height, transform.top);
            transform.left = rangeBind(invert(overflow.width) * upperBoundFactor, overflow.width * upperBoundFactor - overflow.width, transform.left);

            return transform;
        }
    }, {
        key: 'transformToProps',
        value: function transformToProps() {
            var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            var scale = this.props.initialScale === 'auto' ? this.calculateAutofitScale() : this.props.initialScale;
            this.applyTransform(this.props.initialTop, this.props.initialLeft, scale, 0, speed);
        }
    }, {
        key: 'ensureValidTransform',
        value: function ensureValidTransform() {
            var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            this.applyTransform(this.state.top, this.state.left, this.state.scale, 0, speed);
        }

        //lifecycle methods

    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            var childElement = _react2.default.Children.only(this.props.children);
            var originalRef = childElement.ref;

            var composedRef = function composedRef(element) {
                _this3.image = element;
                if (typeof originalRef === 'function') {
                    originalRef(element);
                }
            };
            return _react2.default.createElement(
                'div',
                { style: { position: 'relative', overflow: 'hidden', width: '100%', height: '100%' } },
                this.props.zoomButtons && _react2.default.createElement(
                    'div',
                    { style: { position: 'absolute', zIndex: 1000 } },
                    _react2.default.createElement(ZoomOutButton, { onClick: function onClick() {
                            return _this3.zoomOut();
                        }, disabled: this.state.scale <= this.minScale }),
                    _react2.default.createElement(ZoomInButton, { onClick: function onClick() {
                            return _this3.zoomIn();
                        }, disabled: this.state.scale >= this.props.maxScale })
                ),
                _react2.default.cloneElement(childElement, {
                    onTouchStart: this.handleTouchStart,
                    onTouchEnd: this.handleTouchEnd,
                    onMouseDown: this.handleMouseDown,
                    onMouseMove: this.handleMouseMove,
                    onMouseUp: this.handleMouseUp,
                    onWheel: this.handleMouseWheel,
                    onDragStart: function onDragStart(event) {
                        return event.preventDefault();
                    },
                    onLoad: this.handleImageLoad,
                    ref: composedRef,
                    style: {
                        cursor: 'pointer',
                        transform: 'translate3d(' + this.state.left + 'px, ' + this.state.top + 'px, 0) scale(' + this.state.scale + ')',
                        transformOrigin: '0 0'
                    }
                })
            );
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.image.addEventListener('touchmove', this.handleTouchMove, { passive: false });
            window.addEventListener("resize", this.handleWindowResize);

            //Using the child image's original parent enables flex items, e.g., dimensions not explicitly set
            this.container = this.image.parentNode.parentNode;
            if (this.image.offsetWidth && this.image.offsetHeight) {
                this.applyConstraints();
                this.transformToProps();
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            if (this.image.offsetWidth && this.image.offsetHeight) {
                this.ensureConstraints();
                if (typeof this.state.scale === 'undefined') {
                    //reset to new props
                    this.transformToProps();
                }
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.image.removeEventListener('touchmove', this.handleTouchMove);
            window.removeEventListener('resize', this.handleWindowResize);
        }

        //sizing methods

    }, {
        key: 'ensureConstraints',
        value: function ensureConstraints() {
            if (this.image.offsetWidth && this.image.offsetHeight) {
                var negativeSpace = this.calculateNegativeSpace(1);
                if (!this.lastUnzoomedNegativeSpace || negativeSpace.height !== this.lastUnzoomedNegativeSpace.height || negativeSpace.width !== this.lastUnzoomedNegativeSpace.width) {

                    //image and/or container dimensions have been set / updated
                    this.applyConstraints();
                    this.forceUpdate();
                }
            }
        }
    }, {
        key: 'applyConstraints',
        value: function applyConstraints() {
            var minScale = 1;
            if (this.props.minScale === 'auto') {
                minScale = this.calculateAutofitScale();
            } else {
                minScale = this.props.minScale;
            }

            if (this.minScale !== minScale) {
                this.minScale = minScale;
                this.ensureValidTransform();
            }

            this.lastUnzoomedNegativeSpace = this.calculateNegativeSpace(1);
        }
    }, {
        key: 'calculateNegativeSpace',
        value: function calculateNegativeSpace() {
            var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.scale;

            //get difference in dimension between container and scaled image
            var width = this.container.offsetWidth - scale * this.image.offsetWidth;
            var height = this.container.offsetHeight - scale * this.image.offsetHeight;
            return {
                width: width,
                height: height
            };
        }
    }, {
        key: 'calculateAutofitScale',
        value: function calculateAutofitScale() {
            var autofitScale = 1;
            if (this.image.offsetWidth > 0) {
                autofitScale = Math.min(this.container.offsetWidth / this.image.offsetWidth, autofitScale);
            }
            if (this.image.offsetHeight > 0) {
                autofitScale = Math.min(this.container.offsetHeight / this.image.offsetHeight, autofitScale);
            }
            return autofitScale;
        }
    }], [{
        key: 'getDerivedStateFromProps',
        value: function getDerivedStateFromProps(nextProps, prevState) {
            if (nextProps.initialTop !== prevState.initialTop || nextProps.initialLeft !== prevState.initialLeft || nextProps.initialScale !== prevState.initialScale) {
                return {
                    initialTop: nextProps.initialTop,
                    initialLeft: nextProps.initialLeft,
                    initialScale: nextProps.initialScale
                };
            } else {
                return null;
            }
        }
    }]);

    return PinchZoomPan;
}(_react2.default.Component);

exports.default = PinchZoomPan;


PinchZoomPan.defaultProps = {
    initialTop: 0,
    initialLeft: 0,
    initialScale: 'auto',
    minScale: 'auto',
    maxScale: 1,
    zoomButtons: true
};

PinchZoomPan.propTypes = {
    children: _propTypes2.default.element.isRequired
};